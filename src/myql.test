section "Static checking tests"

test "condition must be boolean" 
    form "" {
        if($error(1)) {
            "X" x: integer
        }
    }

test "condition must be boolean (complex)" 
    form "" {
        "A" a: integer
        "B" b: integer
        if($error(a + b)) {
            "X" x: integer
        }
    }

test "conditions are type checked" 
    form "" {
        if($error(true) < 3) {
            "X" x: integer
        }
    }

test "undefined reference in computed question" 
    form "" {
        "bug" x: integer = $error(y)
    }

test "undefined reference in condition" 
    form "" {
        if ($error(x)) {
            "Y" y: integer
        }
    }

test "nested undefined reference" 
    form "" {
        if (1 > $error(x)) {
            "Y" y: integer
        }
    }


test "empty prompt"
    form "" {
        $warning("" x: integer)
    }

test "useless conditional"
    form "" {
        if ($warning(true))
            "X" x: integer
    }

test "empty then branch" 
    form "" {
        if (2 > 1) 
            $warning({})
    }

test "empty else branch" 
    form "" {
        if (2 > 1) 
            "X" x: integer 
        else 
            $warning({})
    }

test "dead else branch"
    form "" {
        if ($warning(true)) 
            "X" x: integer
        else 
            "Y" y: integer

    }

test "dead then branch with else"
    form "" {
        if (false) 
            $warning("X" x: integer)
        else 
            "Y" y: integer
    }

test "dead then branch"
    form "" {
        if (false) 
            $warning("" x: integer)
    }

test "computed question expression must match declared type"
    form "" {
        "X" x: integer = $error(true)
    }

test "redeclared with different type" 
    form "" {
        "X" x: integer
        $error("X" x: boolean)
    }


test "redeclared with different prompt" 
    form "" {
        "foo" x: integer
        $warning("bar" x: integer)
    }



test "duplicate labels" 
    form "" {
        "same" x: integer
        $warning("same" y: boolean)
    }

test "invalid operand to +" 
    form "" {
        "X" x: integer = $error(true) + 1
    }

test "invalid operands to +" 
    form "" {
        "X" x: integer = $error(true) + $error("hello")
    }

test "direct cylic data dependency"
    form "" {
        $error("X" x: integer = x)
    }


test "indirect cylic data dependency"
    form "" {
        $error("X" x: integer = y)
        $error("Y" y: integer = z)
        $error("Z" z: integer = x)
    }


test "direct cylic control dependency"
    form "" {
        if (x > 1)
            $error("X" x: integer = 20)
    }

test "indirect cylic data dependency"
    form "" {
        if (x > 1)
            $error("Y" y: integer = 10)
        if (y > 1)
            $error("X" x: integer = 20)
    }

section "Dynamic semantics tests"

test "initial state"  
    with 
    form "" {
        "x" x: boolean
        "y" y: integer
        "z" z: string
    }
    = {x: false, y: 0, z: ""}

test "computed questions are initialized" 
    with 
    form "" {
        "x" x: boolean = true
        "y" y: integer = 42
        "z" z: string = "hello world!"
    }
    = {x: true, y: 42, z: "hello world!"}

test "disabled questions are not changed"
    with x: 10
    form "" {
        if (1 > 2) "x" x: integer
    }
    = {x: 0}

test "questions retain values across visibility changes"
    with x: true, y: 42, x: false, z: 2, x: true
    form "" {
        "X" x: boolean
        if (x) 
            "Y" y: integer
        "Z" z: integer
        "Sum" sum: integer = z + y
    }
    = {x: true, y: 42, z: 2, sum: 44}

test "referencing works out of order"
    with x: 10
    form "" {
        "y" y: integer = x
        "x" x: integer
    }
    = {x: 10, y: 10}

test "fixpoint evaluation" 
    with c: 10
    form "" {
        "A" a: integer = c+b+1
        "B" b: integer = c+1
        "C" c: integer
    }
    = {a: 22, b: 11, c: 10}


test "multiplication has higher precedence than addition"
    with
    form "" {
        "X" x: integer = 1 + 2 * 3
    }
    = {x: 7}

test "subtraction associates to the left"
    with
    form "" {
        "X" x: integer = 1 - 2 - 3
    }
    = {x: -4}

test "parentheses override associativity"
    with
    form "" {
        "X" x: integer = 1 - (2 - 3)
    }
    = {x: 2}

section "Rendering tests"

test "empty form renders empty" 
    with
    form "" {
    }
    renders as [
    ]

test "disabled questions don't render"
    with
    form "" {
        if (1 > 2) {
            "X" x: integer
        }
    }
    renders as [
    ]


test "enabled questions render"
    with cond: true
    form "" {
        "C" cond: boolean
        if (cond) {
            "X" x: integer
        }
    }
    renders as [
        "C" cond: boolean
        "X" x: integer
    ]


test "unconditional questions render"
    with
    form "" {
        "X" x: integer
        "Y" y: integer
    }
    renders as [
        "X" x: integer
        "Y" y: integer
    ]

test "computed questions render with value"
    with x: 10
    form "" {
        "X" x: integer
        "Y" y: integer = x + x
    }
    renders as [
        "X" x: integer
        "Y" y: integer = 20
    ]